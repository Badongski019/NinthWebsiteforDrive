<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Always ‚Ä¢ AR Experience</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        :root {
            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: #000;
            font-family: -apple-system, system-ui, sans-serif;
            position: fixed;
        }
        #app-container {
            position: relative; 
            width: 100vw; 
            height: 100vh;
            display: flex; 
            align-items: center; 
            justify-content: center;
        }
        /* Mirroring for selfie feel */
        #webcam {
            position: absolute;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            visibility: hidden; /* We only need the data, not the element view */
        }
        #output_canvas {
            position: absolute;
            width: 100%; height: 100%;
            /* Mirror the Three.js output to match user movements */
            transform: scaleX(-1);
        }
        #ui-overlay {
            position: absolute; inset: 0;
            pointer-events: none;
            z-index: 10;
            display: flex; flex-direction: column;
            justify-content: space-between;
            padding: calc(var(--safe-top) + 20px) 20px calc(var(--safe-bottom) + 20px);
        }
        .gesture-hint {
            color: rgba(255, 255, 255, 0.8);
            text-align: center; 
            font-size: clamp(12px, 2vw, 16px);
            text-transform: uppercase; 
            letter-spacing: 2px;
            text-shadow: 0 2px 15px rgba(0,0,0,0.8);
        }
        #loading-screen {
            position: fixed; inset: 0; background: #0a0412;
            z-index: 100; display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: #ff85a1;
        }
        .loader { 
            width: 50px; height: 50px; 
            border: 4px solid rgba(255, 133, 161, 0.2); 
            border-top-color: #ff85a1; 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Desktop specific UI tweaks */
        @media (min-width: 1024px) {
            .gesture-hint { letter-spacing: 4px; }
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <p style="margin-top: 20px; font-weight: 300; letter-spacing: 1px;">AWAKENING MAGIC...</p>
    </div>

    <div id="app-container">
        <video id="webcam" playsinline></video>
        <canvas id="output_canvas"></canvas>
        
        <div id="ui-overlay">
            <div class="gesture-hint" id="mode-text">Calibrating Camera</div>
            <div class="gesture-hint">‚òùÔ∏è Draw | ü§è Heart | üíû Message</div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output_canvas');
        const modeText = document.getElementById('mode-text');
        let currentMode = "IDLE";
        
        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvasElement, 
            alpha: true, 
            antialias: true,
            powerPreference: "high-performance" 
        });
        
        function updateRendererSize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }
        updateRendererSize();

        // Create Background Video Texture
        const videoTexture = new THREE.VideoTexture(videoElement);
        scene.background = videoTexture;

        // Particle System for Drawing
        const particleCount = 700;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        const pMaterial = new THREE.PointsMaterial({
            size: 0.08,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            map: createCircleTexture(),
            depthWrite: false
        });

        const particleSystem = new THREE.Points(geometry, pMaterial);
        scene.add(particleSystem);
        let pIdx = 0;

        // 3D Heart (Improved Visuals)
        const heartGroup = new THREE.Group();
        const heartPoints = [];
        for (let i = 0; i < 2000; i++) {
            const t = Math.random() * Math.PI * 2;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            heartPoints.push(new THREE.Vector3(x * 0.06, y * 0.06, (Math.random() - 0.5) * 0.5));
        }
        const heartGeo = new THREE.BufferGeometry().setFromPoints(heartPoints);
        const heartMat = new THREE.PointsMaterial({ 
            color: 0xff4d8d, 
            size: 0.04, 
            transparent: true, 
            opacity: 0, 
            blending: THREE.AdditiveBlending 
        });
        const heartParticles = new THREE.Points(heartGeo, heartMat);
        heartGroup.add(heartParticles);
        scene.add(heartGroup);

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,150,200,0.8)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            return tex;
        }

        // --- MEDIAPIPE HANDS ---
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1, // Better tracking for Desktop/High-end mobile
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                document.getElementById('loading-screen').style.opacity = '0';
                setTimeout(() => document.getElementById('loading-screen').style.display = 'none', 500);
                
                const hand = results.multiHandLandmarks[0];
                const indexTip = hand[8];
                const thumbTip = hand[4];

                // Responsive Coordinate Mapping
                // Mapping 0-1 from MediaPipe to Three.js space based on Frustum
                const aspect = window.innerWidth / window.innerHeight;
                const x = (indexTip.x - 0.5) * (aspect * 7.5); 
                const y = (0.5 - indexTip.y) * 7.5;
                const z = indexTip.z * -10;

                // Gesture logic
                const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                const isIndexUp = indexTip.y < hand[6].y && hand[12].y > hand[10].y;
                const isTwoHands = results.multiHandLandmarks.length === 2;

                if (isTwoHands) {
                    currentMode = "LOVE_RELEASE";
                    heartGroup.scale.setScalar(1.5);
                } else if (pinchDist < 0.05) {
                    currentMode = "HEART_CONTROL";
                    heartMat.opacity = Math.min(heartMat.opacity + 0.1, 1);
                    heartGroup.position.lerp(new THREE.Vector3(x, y, 0), 0.15);
                    heartGroup.rotation.y += 0.04;
                } else if (isIndexUp) {
                    currentMode = "DRAWING";
                    drawParticle(x, y, z);
                    heartMat.opacity *= 0.9;
                } else {
                    currentMode = "IDLE";
                    heartMat.opacity *= 0.95;
                    heartGroup.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                }

                updateUI(currentMode);
            }
        }

        function drawParticle(x, y, z) {
            const i = pIdx * 3;
            positions[i] = x;
            positions[i+1] = y;
            positions[i+2] = z;
            
            // Neon Pink to Deep Violet Transition
            colors[i] = 1.0; 
            colors[i+1] = 0.2 + (Math.random() * 0.3);
            colors[i+2] = 0.8;
            
            pIdx = (pIdx + 1) % particleCount;
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
        }

        function updateUI(mode) {
            if (modeText.innerText !== mode.replace('_', ' ')) {
                modeText.innerText = mode.replace('_', ' ');
            }
        }

        // Camera Logic
        const camera_mp = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });
        camera_mp.start();

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Particle Life Cycle (Physics)
            const pos = geometry.attributes.position.array;
            for(let i=0; i<particleCount*3; i+=3) {
                pos[i+1] -= 0.005; // Gentle float down
                pos[i] += (Math.random() - 0.5) * 0.002; // Brownian noise
            }
            geometry.attributes.position.needsUpdate = true;
            
            // Heart floating animation
            heartGroup.position.y += Math.sin(Date.now() * 0.002) * 0.002;
            heartGroup.rotation.z = Math.sin(Date.now() * 0.001) * 0.05;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', updateRendererSize);

    </script>
</body>
</html>