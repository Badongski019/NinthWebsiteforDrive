<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Always ‚Ä¢ AR Experience</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        :root { 
            --safe-top: env(safe-area-inset-top); 
            --safe-bottom: env(safe-area-inset-bottom); 
            --glow: #b66dff; 
            --lilac: #9932CC;
        }
        
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #000; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            position: fixed; 
        }

        #app-container { position: relative; width: 100vw; height: 100vh; }
        #output_canvas { position: absolute; inset: 0; width: 100%; height: 100%; transform: scaleX(-1); z-index: 5; }
        /* Adjusted for mobile: ensures video is hidden but active */
        #webcam { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }

        #loading-screen {
            position: fixed; inset: 0; 
            background: radial-gradient(circle at center, #1a0b2e 0%, #0a0412 100%);
            z-index: 100; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; color: var(--glow);
            transition: all 0.8s ease;
        }

        .intro-ui { text-align: center; display: none; }
        .mode-btn {
            display: block; width: 280px; margin: 15px; padding: 22px;
            background: rgba(255, 255, 255, 0.03); border: 1px solid var(--glow);
            color: white; border-radius: 50px; font-size: 13px; 
            letter-spacing: 3px; cursor: pointer; transition: 0.4s;
            text-transform: uppercase; backdrop-filter: blur(10px);
            -webkit-tap-highlight-color: transparent;
        }
        .mode-btn:active { background: var(--glow); transform: scale(0.95); }

        #toolbar {
            position: absolute; top: calc(var(--safe-top) + 25px); right: 25px;
            display: flex; flex-direction: column; gap: 18px; z-index: 20;
        }
        .tool-btn {
            width: 58px; height: 58px; border-radius: 50%; 
            background: rgba(0,0,0,0.7); border: 1.5px solid var(--glow); 
            color: white; font-size: 22px; display: flex; 
            align-items: center; justify-content: center;
            cursor: pointer; backdrop-filter: blur(15px); transition: 0.3s;
        }

        #ui-overlay {
            position: absolute; inset: 0; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: flex-end;
            padding-bottom: calc(var(--safe-bottom) + 50px); opacity: 0;
        }
        .gesture-hint { 
            color: white; text-align: center; font-size: 10px; 
            letter-spacing: 2px; text-transform: uppercase; margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .loader { width: 40px; height: 40px; border: 3px solid rgba(182,109,255,0.1); border-top-color: var(--glow); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div id="startup-loader" class="loader"></div>
        <div class="intro-ui" id="intro-controls">
            <h1 style="font-weight:200; letter-spacing:10px; color:white; margin-bottom:40px; font-size: 24px;">ALWAYS</h1>
            <button class="mode-btn" onclick="startExperience('draw')">PRACTICE DRAWING</button>
            <button class="mode-btn" onclick="startExperience('galaxy')">GALAXY HEART</button>
        </div>
        <p id="loading-text" style="margin-top:25px; font-size:9px; letter-spacing:3px; opacity:0.6;">TAP A MODE TO START</p>
    </div>

    <div id="app-container">
        <video id="webcam" playsinline muted autoplay></video>
        <canvas id="output_canvas"></canvas>
        <div id="toolbar" style="display: none;">
            <button class="tool-btn" id="undo-btn">‚Ü©Ô∏è</button>
            <button class="tool-btn" id="erase-btn">üßπ</button>
            <button class="tool-btn" id="exit-btn" onclick="location.reload()">‚úñ</button>
        </div>
        <div id="ui-overlay">
            <div class="gesture-hint" id="mode-text">INITIALIZING CAMERA...</div>
            <div class="gesture-hint" id="sub-hint">ü§è PINCH TO DRAW | üñêÔ∏è OPEN HAND TO SPLASH</div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('webcam');
        const canvasElement = document.getElementById('output_canvas');
        const loadingScreen = document.getElementById('loading-screen');
        const toolbar = document.getElementById('toolbar');
        const modeText = document.getElementById('mode-text');
        
        let appMode = 'draw';
        let isStarted = false;
        let isEraser = false;
        let isExploding = false;
        let strokes = [];
        let currentStroke = null;

        // THREE.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true, antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        const videoTexture = new THREE.VideoTexture(videoElement);
        scene.background = videoTexture;

        // --- HEART ENGINE ---
        const heartGroup = new THREE.Group();
        const particleCount = 4000; // Reduced for better mobile performance
        const positions = new Float32Array(particleCount * 3);
        const basePositions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const t = Math.random() * Math.PI * 2;
            const x_base = 16 * Math.pow(Math.sin(t), 3);
            const y_base = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            const r = Math.pow(Math.random(), 0.5); 
            const ix = i * 3;
            basePositions[ix] = x_base * 0.08 * r;
            basePositions[ix+1] = y_base * 0.08 * r;
            basePositions[ix+2] = (Math.random() - 0.5) * 1.5 * r;
            positions[ix] = basePositions[ix];
            positions[ix+1] = basePositions[ix+1];
            positions[ix+2] = basePositions[ix+2];
        }

        const heartGeo = new THREE.BufferGeometry();
        heartGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const heartMat = new THREE.PointsMaterial({ color: 0x9932CC, size: 0.05, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
        const heartParticles = new THREE.Points(heartGeo, heartMat);
        heartGroup.add(heartParticles);
        scene.add(heartGroup);

        // MediaPipe Hands Setup
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        
        hands.onResults((results) => {
            if (!isStarted) return;
            if (appMode !== 'galaxy') heartMat.opacity = 0;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                const index = hand[8];
                const thumb = hand[4];
                const pinky = hand[20];
                
                const x = (index.x - 0.5) * 10;
                const y = (0.5 - index.y) * 10;

                const pinchDist = Math.hypot(index.x - thumb.x, index.y - thumb.y);
                const palmDist = Math.hypot(index.x - pinky.x, index.y - pinky.y);
                const isPinching = pinchDist < 0.06;
                isExploding = palmDist > 0.18; 

                if (appMode === 'galaxy') {
                    heartMat.opacity = 0.9;
                    heartGroup.position.lerp(new THREE.Vector3(x, y, 0), 0.2);
                    modeText.innerText = isExploding ? "‚úß FIREWORKS ‚úß" : (isPinching ? "‚ú¶ SOUL BOND ‚ú¶" : "GALAXY HEART");
                } else {
                    if (isPinching) {
                        if (isEraser) eraseAt(x, y);
                        else {
                            if (!currentStroke) createNewStroke();
                            addPointToStroke(x, y);
                        }
                    } else { currentStroke = null; }
                    modeText.innerText = isEraser ? "ERASER ACTIVE" : "DRAWING MODE";
                }
            } else {
                modeText.innerText = "WAITING FOR HAND...";
            }
        });

        function createNewStroke() {
            const geo = new THREE.BufferGeometry();
            const mat = new THREE.PointsMaterial({ color: 0x9932CC, size: 0.08, transparent: true, blending: THREE.AdditiveBlending });
            const points = new THREE.Points(geo, mat);
            currentStroke = { points, positions: [] };
            strokes.push(currentStroke);
            scene.add(points);
        }

        function addPointToStroke(x, y) {
            for(let i=0; i<5; i++) {
                currentStroke.positions.push(x + (Math.random()-0.5)*0.1, y + (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1);
            }
            currentStroke.points.geometry.setAttribute('position', new THREE.Float32BufferAttribute(currentStroke.positions, 3));
        }

        function eraseAt(x, y) {
            for (let i = strokes.length - 1; i >= 0; i--) {
                const pos = strokes[i].points.geometry.attributes.position.array;
                for(let j=0; j<pos.length; j+=3) {
                    if(Math.hypot(pos[j]-x, pos[j+1]-y) < 0.6) {
                        scene.remove(strokes[i].points);
                        strokes.splice(i, 1);
                        break;
                    }
                }
            }
        }

        // --- CAMERA FIX FOR MOBILE ---
        async function startExperience(mode) {
            appMode = mode;
            isStarted = true;
            
            // UI Transition
            loadingScreen.style.opacity = '0';
            setTimeout(() => { loadingScreen.style.display = 'none'; }, 800);
            toolbar.style.display = 'flex';
            document.getElementById('ui-overlay').style.opacity = '1';
            
            const isDraw = mode === 'draw';
            document.getElementById('undo-btn').style.display = isDraw ? 'flex' : 'none';
            document.getElementById('erase-btn').style.display = isDraw ? 'flex' : 'none';

            try {
                // Request camera with specific mobile constraints
                const constraints = {
                    video: {
                        facingMode: "user",
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                
                // Critical for iOS: Wait for metadata and then play
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    const cameraUtils = new Camera(videoElement, {
                        onFrame: async () => {
                            await hands.send({ image: videoElement });
                        },
                        width: 640,
                        height: 480
                    });
                    cameraUtils.start();
                };
            } catch (err) {
                alert("Camera Error: Please allow camera access and use HTTPS.");
                console.error(err);
            }
        }

        document.getElementById('undo-btn').onclick = () => { if(strokes.length > 0) scene.remove(strokes.pop().points); };
        document.getElementById('erase-btn').onclick = () => {
            isEraser = !isEraser;
            document.getElementById('erase-btn').style.background = isEraser ? "var(--lilac)" : "rgba(0,0,0,0.7)";
        };

        window.onload = () => {
            document.getElementById('startup-loader').style.display = 'none';
            document.getElementById('intro-controls').style.display = 'block';
        };

        function animate() {
            requestAnimationFrame(animate);
            if (isStarted) {
                const posAttr = heartGeo.attributes.position;
                for (let i = 0; i < particleCount; i++) {
                    const ix = i * 3;
                    if (isExploding && appMode === 'galaxy') {
                        velocities[ix] += (Math.random() - 0.5) * 0.1;
                        positions[ix] += velocities[ix];
                        positions[ix+1] += (Math.random() - 0.5) * 0.1;
                    } else {
                        positions[ix] += (basePositions[ix] - positions[ix]) * 0.1;
                        positions[ix+1] += (basePositions[ix+1] - positions[ix+1]) * 0.1;
                        velocities[ix] *= 0.9;
                    }
                }
                posAttr.needsUpdate = true;
                heartGroup.rotation.y += 0.01;
                renderer.render(scene, camera);
            }
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
